library(tidyverse)
library(popbio)
## matrix multiplication Basics
myMat <- matrix(c(0,2,0.5,0.01), nrow = 2, byrow = TRUE)
myMat
# multiply once
myMat %*% n0
# vector of starting population sizes
n0<-c(10,10)
# multiply once
myMat %*% n0
?matrix
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- matrix('numeric', nrow = 20, ncol = 2)
pops
pops[1,] <- n0
pops[1,]
for (i in 2:20){
pops[i,]<-myMat %*% pops[(i-1),]
}
pops[(2,]
pops[(2),]
pops[(1),]
i = 2
pops[(i-1),]
myMat
myMat %*% pops[(i-1),]
pops <- matrix('NA', nrow = 20, ncol = 2)
pops[1,] <- n0
for (i in 2:20){
pops[i,]<-myMat %*% pops[(i-1),]
}
pops[(i-1),] %*% myMat
myMat %*% t(pops[(i-1),])
pops
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- matrix('numeric', nrow = 20, ncol = 2)
pops[1,] <- n0
pops
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- matrix(data = 'numeric', nrow = 20, ncol = 2)
pops
pops[1,] <- n0
pops
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- matrix(data = NA, nrow = 20, ncol = 2)
pops[1,] <- n0
pops
myMat %*% pops[(i-1),]
for (i in 2:20){
pops[i,]<-myMat %*% pops[(i-1),]
}
pops
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- data.frame(data = NA, nrow = 20, ncol = 2)
pops[1,] <- n0
data.frame(data = NA, nrow = 20, ncol = 2)
# LOOP to multiply
# collection zone to collect J and A numbers
pops <- matrix(data = NA, nrow = 20, ncol = 2)
pops[1,] <- n0
times <- 50
pops <- matrix(data = NA, nrow = times, ncol = 2)
times <- 50
pops <- matrix(data = NA, nrow = times, ncol = 2)
pops[1,] <- n0
for (i in 2:times){
pops[i,]<-myMat %*% pops[(i-1),]
}
matplot(pops)
matplot(pops, type = 'l')
times <- 50
pops <- matrix(data = NA, nrow = times, ncol = 2)
pops[1,] <- n0
for (i in 2:times){
pops[i,]<-myMat %*% t(pops[(i-1),])
}
myMat <- matrix(c(0,2,0.5,0.1), nrow = 2, byrow = TRUE)
myMat
# vector of starting population sizes
n0<-c(10,10)
# multiply once
myMat %*% n0
times <- 50
pops <- matrix(data = NA, nrow = times, ncol = 2)
pops[1,] <- n0
for (i in 2:times){
pops[i,]<-myMat %*% pops[(i-1),]
}
matplot(pops, type = 'l')
pops
plotPops <- as.data.frame(pops)
names(plotPops) <- c("J", "A")
plotPops <- as.data.frame(pops)
names(plotPops) <- c("J", "A")
plotPops <- mutate(plotPops, totalN = J+A)
plotPops
plotPops <- as.data.frame(pops)
names(plotPops) <- c("J", "A")
plotPops <- mutate(plotPops, totalN = J+A, time = 1:times)
plotPops
ggplot(plotPops, aes(x = time , y = J))+
geom_line()
ggplot(plotPops, aes(x = time , y = J))+
geom_line()+
geom_line(aes(x = time, y = A, colour = 'red'))+
geom_line(aes(x = time, y = totalN, colour = "green"))
ggplot(plotPops, aes(x = time , y = J))+
geom_line()+
geom_line(aes(x = time, y = A), colour = 'red'))+
geom_line(aes(x = time, y = totalN), colour = "green"))
ggplot(plotPops, aes(x = time , y = J))+
geom_line()+
geom_line(aes(x = time, y = A), colour = 'red')+
geom_line(aes(x = time, y = totalN), colour = "green")
ggplot(plotPops, aes(x = time , y = J))+
geom_line()+
geom_line(aes(x = time, y = A), colour = 'red')+
geom_line(aes(x = time, y = totalN), colour = "green")+
scale_y_log10()
# roughly calcuate stable age
mutate(plotPops, propJ = J/totalN, propA = A/totalN)
# roughly calcuate stable age
mutate(plotPops, propJ = J/totalN, propA = A/totalN) %>% tail
## eigen magic
eigen(myMat)
with(plotPops, J/A)
with(plotPops, A/J)
## eigen magic
eigen(myMat)
# roughly calcuate stable age
mutate(plotPops, propJ = J/totalN, propA = A/totalN) %>% tail
## eigen magic
eigen(myMat)
?popbio
# popbio magic
lambda(myMat)
stable.stage(myMat)
stable.stage
?Re
eigen(myMat)$vectors
eigen(myMat)$vectors[,1]
eigen(myMat)$vectors[,1]/sum(eigen(myMat)$vectors[,1])
?pop.projection
pop.projection(myMat, n, 50)
myMat
n <- c(10,10)
pop.projection(myMat, n, 50)
stage.vector.plot(out)
out <- pop.projection(myMat, n, 50)
stage.vector.plot(out)
stage.vector.plot(out$stage.vectors)
plot(out)
out
names(out)
matplot(t(out$stage.vectors))
matplot(t(out$stage.vectors), type = 'l')
out$pop.sizes
myMat <- matrix(c(0,2,0.5,0.1), nrow = 2, byrow = TRUE)
myMat
Reduce(f=function(v, x) myMat %*% v, x=1:100, init=c(10,10), accumulate=TRUE)
Reduce(f=function(v, x) myMat %*% v, x=1:50,
init=c(10,10), accumulate=TRUE)
n0<-c(10,10)
# multiply once
myMat %*% n0
# LOOP to multiply
# collection zone to collect J and A numbers
times <- 50
pops <- matrix(data = NA, nrow = times, ncol = 2)
pops[1,] <- n0
for (i in 2:times){
pops[i,]<-myMat %*% pops[(i-1),]
}
pops
Reduce(f=function(v, x) myMat %*% v, x=1:50,
init=c(10,10), accumulate=TRUE)
?Reduce
?purrr:reduce
?purrr::reduce
purrr::reduce(f=function(v, x) myMat %*% v, x=1:50,
init=c(10,10))
purrr::reduce(.f=function(v, x) myMat %*% v, .x=1:50,
.init=c(10,10))
purrr::reduce(.f=function(v, x) myMat %*% v, .x=1:50,
.init=c(10,10), accumulate = TRUE)
purrr::reduce(.f=function(v, x) myMat %*% v, .x=1:50,
.init=c(10,10), print)
purrr::reduce(.f=function(v, x) print(myMat %*% v), .x=1:50,
.init=c(10,10))
as.data.frame(purrr::reduce(.f=function(v, x) print(myMat %*% v), .x=1:50,
.init=c(10,10)))
# Functional Programming style
Reduce(f=function(v, x) myMat %*% v, x=1:50,
init=c(10,10), accumulate=TRUE)
purrr::reduce(.f=function(v, x) print(myMat %*% v), .x=1:50,
.init=c(10,10))
purrr::reduce(.f=function(v, x) left_join(myMat %*% v), .x=1:50,
.init=c(10,10))
# libraries we need
# install these first (only once!!) -> over there in packages tab.
library(tidyverse)
reduce(.f=function(v, x) left_join(myMat %*% v), .x=1:50,
.init=c(10,10))
accumulate(.f=function(v, x) myMat %*% v, .x=1:50,
.init=c(10,10))
install.packages("popbio")
head(pops)
pops
# First define the number of years
# how many years into the future
times <- 50
# Second, make a collection bin
pops <-matrix(data = NA, nrow = times, ncol = 2)
# Third, make the first row of pops = c(10,10)
# the pops[1,] is read to be ROW 1 of pops
pops[1,] <- n0
n0 <- c(10,10)
myMat %*% n0
myMat <- matrix(c(0,2,0.5,0.1), nrow = 2, byrow = TRUE)
myMat
n0 <- c(10,10)
myMat %*% n0
# First define the number of years
# how many years into the future
times <- 50
# Second, make a collection bin
pops <-matrix(data = NA, nrow = times, ncol = 2)
# Third, make the first row of pops = c(10,10)
# the pops[1,] is read to be ROW 1 of pops
pops[1,] <- n0
for (i in 2:times){
pops[i,] <- myMat %*% pops[(i-1),]
head(pops)
}
popbio::pop.projection()
popbio::pop.projection
